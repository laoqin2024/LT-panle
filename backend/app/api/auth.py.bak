"""
认证相关API路由
"""
from datetime import datetime, timedelta
from fastapi import APIRouter, Depends, HTTPException, status, Request
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from sqlalchemy.orm import selectinload
from app.core.database import get_db
from app.core.security import (
    verify_password,
    create_access_token,
    create_refresh_token,
    verify_token,
    ACCESS_TOKEN_EXPIRE_MINUTES,
)
from app.models.user import User, UserSession
from app.api.schemas import (
    LoginRequest,
    LoginResponse,
    TokenResponse,
    UserResponse,
    RefreshTokenRequest,
    MessageResponse,
)
from app.api.dependencies import get_current_user

router = APIRouter(prefix="/auth", tags=["认证"])


@router.post("/login", summary="用户登录")  # 移除response_model，因为返回格式与模型不完全匹配
async def login(
    login_data: LoginRequest,
    request: Request,
    db: AsyncSession = Depends(get_db)
):
    """
    用户登录接口
    
    - **username**: 用户名
    - **password**: 密码
    
    返回access_token和用户信息
    """
    # 查询用户（支持用户名或邮箱登录），同时加载角色关系
    result = await db.execute(
        select(User)
        .options(selectinload(User.role))
        .where(
            (User.username == login_data.username) | 
            (User.email == login_data.username)
        )
    )
    user = result.scalar_one_or_none()
    
    # 验证用户
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="用户名或密码错误"
        )
    
    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="用户已被禁用"
        )
    
    # 验证密码
    if not verify_password(login_data.password, user.password_hash):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="用户名或密码错误"
        )
    
    # 更新最后登录时间
    user.last_login = datetime.utcnow()
    await db.commit()
    await db.refresh(user)
    
    # 创建token
    token_data = {
        "sub": str(user.id),
        "username": user.username,
        "email": user.email,
    }
    access_token = create_access_token(token_data)
    refresh_token = create_refresh_token(token_data)
    
    # 创建用户会话记录
    try:
        # 获取客户端IP和User-Agent
        client_ip = request.client.host if request.client else None
        user_agent = request.headers.get("user-agent", "")
        
        # 计算过期时间
        expires_at = datetime.utcnow() + timedelta(days=7)
        
        session = UserSession(
            user_id=user.id,
            token=access_token,
            ip_address=client_ip,
            user_agent=user_agent,
            expires_at=expires_at,
        )
        db.add(session)
        await db.commit()
    except Exception as e:
        # 会话创建失败不影响登录，只记录错误
        print(f"创建用户会话失败: {e}")
    
    # 获取角色名称（需要重新加载关系）
    role_name = None
    try:
        # 确保角色关系已加载
        if hasattr(user, 'role') and user.role:
            role_name = user.role.name
        else:
            # 如果关系未加载，手动查询
            from app.models.user import Role
            role_result = await db.execute(
                select(Role).where(Role.id == user.role_id)
            )
            role = role_result.scalar_one_or_none()
            if role:
                role_name = role.name
    except Exception as e:
        print(f"获取角色名称失败: {e}")
        role_name = None
    
    # 构建响应
    user_response = UserResponse(
        id=user.id,
        username=user.username,
        email=user.email,
        full_name=user.full_name,
        role_id=user.role_id,
        role_name=role_name,
        is_active=user.is_active,
        is_superuser=user.is_superuser,
        last_login=user.last_login,
        created_at=user.created_at,
    )
    
    # 构建响应（前端期望 token 和 user）
    # 使用model_dump()（Pydantic v2）或dict()（Pydantic v1）
    try:
        user_dict = user_response.model_dump() if hasattr(user_response, 'model_dump') else user_response.dict()
    except Exception:
        # 如果都不可用，直接使用对象（FastAPI会自动序列化）
        user_dict = user_response
    
    response_data = {
        "token": access_token,  # 前端使用这个字段
        "access_token": access_token,
        "refresh_token": refresh_token,
        "token_type": "bearer",
        "expires_in": ACCESS_TOKEN_EXPIRE_MINUTES * 60,
        "user": user_dict,
    }
    
    # 返回字典（FastAPI会自动序列化）
    return response_data
    except Exception as e:
        # 记录详细错误信息
        import traceback
        error_detail = traceback.format_exc()
        print(f"登录接口错误: {e}")
        print(error_detail)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"登录失败: {str(e)}"
        )


@router.post("/refresh", response_model=TokenResponse, summary="刷新Token")
async def refresh_token(
    refresh_data: RefreshTokenRequest,
    db: AsyncSession = Depends(get_db)
):
    """
    刷新访问令牌
    
    使用refresh_token获取新的access_token
    """
    # 验证refresh_token
    payload = verify_token(refresh_data.refresh_token)
    if not payload:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="无效的refresh_token"
        )
    
    # 检查token类型
    if payload.get("type") != "refresh":
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="无效的token类型"
        )
    
    # 获取用户ID
    user_id = payload.get("sub")
    if not user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="token中缺少用户信息"
        )
    
    # 查询用户
    result = await db.execute(select(User).where(User.id == int(user_id)))
    user = result.scalar_one_or_none()
    
    if not user or not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="用户不存在或已被禁用"
        )
    
    # 创建新的access_token
    token_data = {
        "sub": str(user.id),
        "username": user.username,
        "email": user.email,
    }
    access_token = create_access_token(token_data)
    
    return TokenResponse(
        access_token=access_token,
        refresh_token=refresh_data.refresh_token,  # refresh_token不变
        token_type="bearer",
        expires_in=ACCESS_TOKEN_EXPIRE_MINUTES * 60,
    )


@router.get("/me", response_model=UserResponse, summary="获取当前用户信息")
async def get_current_user_info(
    current_user: User = Depends(get_current_user)
):
    """
    获取当前登录用户的信息
    """
    role_name = None
    if current_user.role:
        role_name = current_user.role.name
    
    return UserResponse(
        id=current_user.id,
        username=current_user.username,
        email=current_user.email,
        full_name=current_user.full_name,
        role_id=current_user.role_id,
        role_name=role_name,
        is_active=current_user.is_active,
        is_superuser=current_user.is_superuser,
        last_login=current_user.last_login,
        created_at=current_user.created_at,
    )


@router.post("/logout", response_model=MessageResponse, summary="用户登出")
async def logout(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    用户登出
    
    删除当前用户的会话记录
    """
    # 删除用户的所有会话（或只删除当前会话）
    # 这里简化处理，删除所有会话
    await db.execute(
        select(UserSession).where(UserSession.user_id == current_user.id)
    )
    result = await db.execute(
        select(UserSession).where(UserSession.user_id == current_user.id)
    )
    sessions = result.scalars().all()
    
    for session in sessions:
        await db.delete(session)
    
    await db.commit()
    
    return MessageResponse(
        message="登出成功",
        success=True
    )

