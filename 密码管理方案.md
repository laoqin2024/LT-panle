# 账号密码管理方案

## 一、总体设计原则

### 1.1 安全原则
- **最小权限原则**: 用户只能访问被授权的资源
- **加密存储**: 所有密码必须加密存储，不能明文保存
- **审计追踪**: 所有密码访问操作都要记录日志
- **定期轮换**: 支持密码定期更换
- **分级管理**: 不同级别的用户有不同的密码访问权限

### 1.2 用户体验原则
- **便捷访问**: 用户无需记住所有密码
- **安全共享**: 支持安全的密码共享机制
- **权限控制**: 清晰的权限管理界面
- **操作记录**: 可查看密码使用历史

---

## 二、技术实现方案

### 2.1 密码加密存储

#### 方案A：AES对称加密（推荐）

**优点**:
- 加密解密速度快
- 适合大量密码存储
- 实现简单

**实现方式**:
```python
# 使用 Fernet (基于 AES-128)
from cryptography.fernet import Fernet
import base64
import os

class PasswordManager:
    def __init__(self):
        # 从环境变量或配置文件读取主密钥
        key = os.getenv('ENCRYPTION_KEY')
        if not key:
            # 首次运行生成密钥
            key = Fernet.generate_key()
            # 保存到安全位置
        self.cipher = Fernet(key)
    
    def encrypt_password(self, password: str) -> str:
        """加密密码"""
        return self.cipher.encrypt(password.encode()).decode()
    
    def decrypt_password(self, encrypted: str) -> str:
        """解密密码"""
        return self.cipher.decrypt(encrypted.encode()).decode()
```

**密钥管理**:
- 主密钥存储在环境变量或密钥管理服务中
- 生产环境建议使用密钥管理服务（如 AWS KMS、HashiCorp Vault）

#### 方案B：非对称加密（更安全，但性能较低）

**适用场景**: 需要更高级别安全性的场景

**实现方式**:
```python
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import hashes, serialization

class PasswordManager:
    def __init__(self):
        # 生成或加载RSA密钥对
        self.private_key = self.load_or_generate_private_key()
        self.public_key = self.private_key.public_key()
    
    def encrypt_password(self, password: str) -> str:
        """使用公钥加密"""
        encrypted = self.public_key.encrypt(
            password.encode(),
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
        return base64.b64encode(encrypted).decode()
    
    def decrypt_password(self, encrypted: str) -> str:
        """使用私钥解密"""
        encrypted_bytes = base64.b64decode(encrypted.encode())
        password = self.private_key.decrypt(
            encrypted_bytes,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
        return password.decode()
```

### 2.2 数据库设计

```sql
-- 凭据表（统一管理所有密码）
CREATE TABLE credentials (
    id SERIAL PRIMARY KEY,
    resource_type VARCHAR(50) NOT NULL,  -- 'server', 'device', 'database', 'site'
    resource_id INTEGER NOT NULL,        -- 关联的资源ID
    credential_type VARCHAR(50) NOT NULL, -- 'password', 'ssh_key', 'api_key'
    username VARCHAR(255),
    password_encrypted TEXT NOT NULL,     -- 加密后的密码
    ssh_key_path TEXT,                   -- SSH密钥路径（如果使用密钥）
    description TEXT,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    created_by INTEGER REFERENCES users(id),
    is_active BOOLEAN DEFAULT TRUE
);

-- 密码访问权限表
CREATE TABLE credential_permissions (
    id SERIAL PRIMARY KEY,
    credential_id INTEGER REFERENCES credentials(id),
    user_id INTEGER REFERENCES users(id),
    permission_type VARCHAR(50) NOT NULL, -- 'view', 'use', 'edit', 'delete'
    granted_by INTEGER REFERENCES users(id),
    granted_at TIMESTAMP DEFAULT NOW(),
    expires_at TIMESTAMP,                -- 权限过期时间（可选）
    UNIQUE(credential_id, user_id, permission_type)
);

-- 密码访问日志表
CREATE TABLE credential_access_logs (
    id SERIAL PRIMARY KEY,
    credential_id INTEGER REFERENCES credentials(id),
    user_id INTEGER REFERENCES users(id),
    action VARCHAR(50) NOT NULL,         -- 'view', 'use', 'decrypt', 'edit'
    ip_address VARCHAR(45),
    user_agent TEXT,
    accessed_at TIMESTAMP DEFAULT NOW(),
    success BOOLEAN DEFAULT TRUE
);

-- 密码历史表（支持密码轮换）
CREATE TABLE credential_history (
    id SERIAL PRIMARY KEY,
    credential_id INTEGER REFERENCES credentials(id),
    password_encrypted TEXT NOT NULL,
    changed_at TIMESTAMP DEFAULT NOW(),
    changed_by INTEGER REFERENCES users(id),
    reason TEXT
);
```

### 2.3 权限控制模型

#### 权限级别

1. **无权限**: 无法查看和使用密码
2. **查看权限** (`view`): 可以查看密码（解密后显示）
3. **使用权限** (`use`): 可以使用密码（自动填充，但不显示明文）
4. **编辑权限** (`edit`): 可以修改密码
5. **删除权限** (`delete`): 可以删除密码

#### 权限继承

- **资源所有者**: 自动拥有所有权限
- **管理员**: 可以管理所有密码权限
- **普通用户**: 需要被明确授权

---

## 三、功能实现方案

### 3.1 密码存储功能

#### 添加密码
```python
# API: POST /api/credentials
{
    "resource_type": "server",
    "resource_id": 1,
    "credential_type": "password",
    "username": "root",
    "password": "plaintext_password",  # 前端传输明文，后端加密存储
    "description": "服务器root密码"
}
```

#### 密码加密流程
```
1. 前端收集密码（明文）
2. 通过HTTPS传输到后端
3. 后端使用主密钥加密
4. 存储加密后的密码
5. 记录操作日志
```

### 3.2 密码访问功能

#### 方案A：按需解密（推荐）

**流程**:
1. 用户请求访问密码
2. 检查用户权限
3. 解密密码
4. 返回给前端（一次性显示或自动填充）
5. 记录访问日志

**API设计**:
```python
# 获取密码（解密）
GET /api/credentials/{id}/password
# 返回: { "password": "decrypted_password" }

# 使用密码（自动填充，不返回明文）
POST /api/credentials/{id}/use
# 用于SSH连接、数据库连接等场景
```

#### 方案B：临时令牌

**流程**:
1. 用户请求访问密码
2. 生成临时令牌（有效期5分钟）
3. 将解密后的密码与令牌关联
4. 前端使用令牌获取密码
5. 令牌过期后自动清除

**优点**: 密码不会长时间暴露在前端

### 3.3 密码共享功能

#### 安全共享机制

**方式1：权限授权**
- 管理员将密码权限授予其他用户
- 被授权用户可以查看或使用密码
- 可以设置权限过期时间

**方式2：临时分享链接**
- 生成带时效的分享链接
- 链接包含加密的密码信息
- 访问后自动失效

**方式3：密码保险箱**
- 创建密码组（Vault）
- 将密码添加到保险箱
- 用户加入保险箱后可以访问其中的密码

### 3.4 密码轮换功能

#### 自动轮换提醒
- 设置密码过期时间
- 到期前提醒更换
- 支持批量轮换

#### 密码历史管理
- 保存历史密码（加密）
- 支持回滚到历史密码
- 记录密码变更原因

---

## 四、前端界面设计

### 4.1 密码管理页面

#### 密码列表
- 显示资源名称、用户名、最后更新时间
- 权限标识（可查看/可使用/可编辑）
- 快速操作（查看、使用、编辑、删除）

#### 添加/编辑密码表单
```
资源类型: [下拉选择: 服务器/设备/数据库/站点]
关联资源: [选择具体资源]
凭据类型: [密码/SSH密钥/API密钥]
用户名: [输入框]
密码: [密码输入框，带显示/隐藏按钮]
描述: [文本输入]
```

### 4.2 密码访问界面

#### 查看密码
- 点击"查看"按钮
- 弹出确认对话框（记录访问）
- 显示解密后的密码（可复制）
- 自动在30秒后隐藏

#### 使用密码
- 点击"使用"按钮
- 自动填充到SSH连接、数据库连接等场景
- 不显示明文密码

### 4.3 权限管理界面

#### 权限列表
- 显示所有用户对当前密码的权限
- 权限类型（查看/使用/编辑/删除）
- 权限过期时间
- 操作（修改权限、撤销权限）

#### 授权界面
- 选择用户
- 选择权限类型
- 设置过期时间（可选）
- 确认授权

---

## 五、安全最佳实践

### 5.1 密码策略

#### 密码强度要求
- 最小长度：12位
- 包含大小写字母、数字、特殊字符
- 不能使用常见密码

#### 密码存储
- 使用强加密算法（AES-256）
- 主密钥安全存储（密钥管理服务）
- 定期轮换主密钥

### 5.2 访问控制

#### 权限验证
- 每次访问密码都验证权限
- 记录所有访问操作
- 异常访问告警

#### 会话管理
- 密码访问需要重新认证
- 敏感操作需要二次确认
- 会话超时自动登出

### 5.3 审计和监控

#### 操作日志
- 记录所有密码相关操作
- 包括：查看、使用、编辑、删除、授权
- 记录IP地址、用户代理、时间戳

#### 异常检测
- 异常时间访问告警
- 频繁访问告警
- 未授权访问尝试告警

### 5.4 密钥管理

#### 主密钥存储
- **开发环境**: 环境变量或配置文件（.env，不提交到Git）
- **生产环境**: 密钥管理服务
  - AWS KMS
  - HashiCorp Vault
  - Azure Key Vault
  - 阿里云KMS

#### 密钥轮换
- 定期轮换主密钥（建议每90天）
- 使用密钥版本管理
- 支持密钥回滚

---

## 六、实现建议

### 6.1 开发阶段

#### 第一阶段：基础功能
1. 密码加密存储（AES对称加密）
2. 密码CRUD操作
3. 基础权限控制（所有者/管理员/用户）

#### 第二阶段：权限管理
1. 细粒度权限控制
2. 权限授权界面
3. 权限过期管理

#### 第三阶段：高级功能
1. 密码共享机制
2. 密码轮换提醒
3. 审计日志查看

### 6.2 技术选型

#### 后端加密库
- **Python**: `cryptography` (Fernet)
- **Node.js**: `crypto` (内置) 或 `node-forge`

#### 密钥管理
- **开发**: 环境变量
- **生产**: HashiCorp Vault（推荐）或云服务商KMS

#### 前端密码输入
- 使用密码输入框（type="password"）
- 提供显示/隐藏切换
- 密码强度指示器

### 6.3 数据库优化

#### 索引设计
```sql
-- 凭据表索引
CREATE INDEX idx_credentials_resource ON credentials(resource_type, resource_id);
CREATE INDEX idx_credentials_user ON credentials(created_by);

-- 权限表索引
CREATE INDEX idx_permissions_credential ON credential_permissions(credential_id);
CREATE INDEX idx_permissions_user ON credential_permissions(user_id);

-- 日志表索引
CREATE INDEX idx_access_logs_credential ON credential_access_logs(credential_id);
CREATE INDEX idx_access_logs_user ON credential_access_logs(user_id);
CREATE INDEX idx_access_logs_time ON credential_access_logs(accessed_at);
```

---

## 七、API设计

### 7.1 凭据管理API

```
POST   /api/credentials              # 创建凭据
GET    /api/credentials              # 获取凭据列表
GET    /api/credentials/{id}         # 获取凭据详情
PUT    /api/credentials/{id}         # 更新凭据
DELETE /api/credentials/{id}         # 删除凭据
GET    /api/credentials/{id}/password # 获取密码（解密）
POST   /api/credentials/{id}/use     # 使用密码（自动填充）
```

### 7.2 权限管理API

```
GET    /api/credentials/{id}/permissions        # 获取权限列表
POST   /api/credentials/{id}/permissions        # 授权
PUT    /api/credentials/{id}/permissions/{user_id} # 修改权限
DELETE /api/credentials/{id}/permissions/{user_id} # 撤销权限
```

### 7.3 审计日志API

```
GET    /api/credentials/{id}/logs               # 获取访问日志
GET    /api/credentials/logs                   # 获取所有日志（管理员）
```

---

## 八、用户体验优化

### 8.1 密码输入

#### 密码生成器
- 提供随机密码生成功能
- 可设置密码长度和复杂度
- 一键复制到剪贴板

#### 密码强度检测
- 实时显示密码强度
- 提供密码建议

### 8.2 快速访问

#### 密码自动填充
- SSH连接时自动填充密码
- 数据库连接时自动填充
- 减少手动输入

#### 密码搜索
- 按资源名称搜索
- 按用户名搜索
- 按标签搜索

### 8.3 安全提示

#### 访问确认
- 查看密码需要确认
- 显示"此操作将被记录"提示
- 敏感操作二次确认

#### 安全建议
- 定期更换密码提醒
- 弱密码警告
- 共享密码安全提示

---

## 九、实施步骤

### 阶段一：基础实现（1-2周）
1. 数据库表设计
2. 密码加密/解密功能
3. 基础CRUD API
4. 密码管理页面

### 阶段二：权限系统（1-2周）
1. 权限模型设计
2. 权限验证中间件
3. 权限管理界面
4. 权限授权功能

### 阶段三：高级功能（1-2周）
1. 密码共享机制
2. 审计日志
3. 密码轮换提醒
4. 安全优化

---

## 十、总结

### 推荐方案

**加密方式**: AES-256对称加密（Fernet）
**密钥管理**: 开发环境用环境变量，生产环境用HashiCorp Vault
**权限模型**: 基于角色的细粒度权限控制
**访问方式**: 按需解密 + 临时令牌

### 安全要点

1. ✅ 所有密码加密存储
2. ✅ 权限严格控制
3. ✅ 操作全程审计
4. ✅ 密钥安全管理
5. ✅ 定期密码轮换

### 用户体验

1. ✅ 便捷的密码访问
2. ✅ 清晰的权限管理
3. ✅ 安全的密码共享
4. ✅ 完善的操作记录

这个方案既保证了安全性，又提供了良好的用户体验。

